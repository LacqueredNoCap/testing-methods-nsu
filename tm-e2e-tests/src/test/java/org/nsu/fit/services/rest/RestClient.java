package org.nsu.fit.services.rest;

import javax.ws.rs.ProcessingException;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.client.*;
import javax.ws.rs.core.MediaType;

import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.UUID;

import com.fasterxml.jackson.core.type.TypeReference;
import com.github.javafaker.Faker;

import org.glassfish.jersey.client.ClientConfig;

import org.nsu.fit.services.log.Logger;
import org.nsu.fit.services.rest.data.*;
import org.nsu.fit.shared.JsonMapper;

public class RestClient {
    //private static final String REST_URI = "http://localhost:8080/tm-backend/rest";
    // Note: uncomment below line if you want to use the docker compose.
    private static final String REST_URI = "http://localhost:8089/tm-backend/rest";

    private static final Client CLIENT =
            ClientBuilder.newClient(new ClientConfig().register(RestClientLogFilter.class));

    private static final Faker FAKER = Faker.instance(Locale.ENGLISH);

    public AccountTokenPojo authenticate(String login, String pass) {
        CredentialsPojo credentialsPojo = new CredentialsPojo(login, pass);

        return post(
                "/authenticate",
                JsonMapper.toJson(credentialsPojo, true),
                AccountTokenPojo.class,
                null
        );
    }

    public HealthCheckPojo healthCheck(){
        return get("/health_check", HealthCheckPojo.class, null);
    }

    public CustomerPojo me(AccountTokenPojo accountTokenPojo){
        return get("/me", CustomerPojo.class, accountTokenPojo);
    }

    public CustomerPojo createAutoGeneratedCustomer(AccountTokenPojo accountToken) {
        // Лабораторная 3: Добавить обработку генерацию фейковых имен, фамилий и логинов.

        ContactPojo contactPojo = new ContactPojo(
                FAKER.name().firstName(),
                FAKER.name().lastName(),
                FAKER.internet().emailAddress(),
                FAKER.internet().password(6, 12, true, true, true),
                FAKER.number().numberBetween(100, 1001)
        );

        return post(
                "/customers",
                JsonMapper.toJson(contactPojo, true),
                CustomerPojo.class,
                accountToken
        );
    }

    public List<CustomerPojo> getCustomerByLogin(String login, AccountTokenPojo accountToken) {
        return get(
                "/customers",
                new TypeReference<List<CustomerPojo>>(){},
                "login",
                login,
                accountToken
        );
    }

    public TopUpBalanceResponse topUpBalance(TopUpBalanceRequest topUpBalanceRequest, AccountTokenPojo accountToken) {
        return post(
                "/customers/top_up_balance",
                JsonMapper.toJson(topUpBalanceRequest, true),
                TopUpBalanceResponse.class,
                accountToken
        );
    }

    public List<CustomerPojo> getCustomers(AccountTokenPojo accountToken) {
        return get("/customers",  (new TypeReference<List<CustomerPojo>>(){}) , accountToken);
    }

    public void deleteCustomer(UUID id, AccountTokenPojo accountToken) {
        delete("customers/" + id, accountToken);
    }

    public PlanPojo createPlan(PlanPojo planPojo, AccountTokenPojo accountToken) {
        return post(
                "/plans",
                JsonMapper.toJson(planPojo,true),
                PlanPojo.class,
                accountToken
        );
    }

    private static <R> R post(String path,
                              String body,
                              Class<R> responseType,
                              AccountTokenPojo accountToken) {
        // Лабораторная 3: Добавить обработку Responses и Errors. Выводите их в лог.
        Invocation.Builder request = CLIENT
                .target(REST_URI)
                .path(path)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        R response = null;
        try {
            String httpResponse = request.post(Entity.json(body), String.class);
            response = JsonMapper.fromJson(httpResponse, responseType);

            Logger.debug("Response: " + response);
        } catch (ProcessingException | WebApplicationException e) {
            Logger.error("Ошибка при вызове POST метода", e);
        } catch (RuntimeException e) {
            Logger.error("Ошибка при парсинге ответа из JSON", e);
        }

        return response;
    }

    private static <R> R get(
            String path,
            Map<String, Object> queryParams,
            Class<R> responseType,
            AccountTokenPojo accountToken) {
        WebTarget target = CLIENT
                .target(REST_URI)
                .path(path);

        if (queryParams != null) {
            for (Map.Entry<String,Object> entry : queryParams.entrySet()) {
                target.queryParam(entry.getKey(),entry.getValue());
            }
        }

        Invocation.Builder request = target
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        R response = null;
        try {
            String httpResponse = request.get(String.class);
            response = JsonMapper.fromJson(httpResponse, responseType);

            Logger.debug("Response: " + response);
        } catch (ProcessingException | WebApplicationException e) {
            Logger.error("Ошибка при вызове GET метода", e);
        } catch (RuntimeException e) {
            Logger.error("Ошибка при парсинге ответа из JSON", e);
        }

        return response;
    }

    private static <R> R get(String path, Class<R> responseType, AccountTokenPojo accountToken)
            throws ProcessingException, WebApplicationException {
        Invocation.Builder request = CLIENT
                .target(REST_URI)
                .path(path)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        R response = null;
        try {
            String httpResponse = request.get(String.class);
            response = JsonMapper.fromJson(httpResponse, responseType);

            Logger.debug("Response: " + response);
        } catch (ProcessingException | WebApplicationException e) {
            Logger.error("Ошибка при вызове GET метода", e);
        } catch (RuntimeException e) {
            Logger.error("Ошибка при парсинге ответа из JSON", e);
        }

        return response;
    }

    private static <R> R get(String path, TypeReference<R> responseType, AccountTokenPojo accountToken)
            throws ProcessingException, WebApplicationException {
        Invocation.Builder request = CLIENT
                .target(REST_URI)
                .path(path)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        R response = null;
        try {
            String httpResponse = request.get(String.class);
            response = JsonMapper.fromJson(httpResponse, responseType);

            Logger.debug("Response: " + response);
        } catch (ProcessingException | WebApplicationException e) {
            Logger.error("Ошибка при вызове GET метода", e);
        } catch (RuntimeException e) {
            Logger.error("Ошибка при парсинге ответа из JSON", e);
        }

        return response;
    }

    private static <R> R get(String path, TypeReference<R> responseType, String queryParamName, Object queryParamObject, AccountTokenPojo accountToken)
            throws ProcessingException, WebApplicationException {
        Invocation.Builder request = CLIENT
                .target(REST_URI)
                .path(path)
                .queryParam(queryParamName, queryParamObject)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        R response = null;
        try {
            String httpResponse = request.get(String.class);
            response = JsonMapper.fromJson(httpResponse, responseType);

            Logger.debug("Response: " + httpResponse);
        } catch (ProcessingException | WebApplicationException e) {
            Logger.error("Ошибка при вызове GET метода", e);
        } catch (RuntimeException e) {
            Logger.error("Ошибка при парсинге ответа из JSON", e);
        }

        return response;
    }

    private static void delete(String path, AccountTokenPojo accountToken)
            throws ProcessingException, WebApplicationException {
        Invocation.Builder request = CLIENT
                .target(REST_URI)
                .path(path)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        try {
            String response = request.delete(String.class);

            Logger.debug("Response: " + response);
        } catch (ProcessingException | WebApplicationException e) {
            Logger.error("Ошибка при вызове DELETE метода", e);
            throw e;
        }

    }

    private static class RestClientLogFilter implements ClientRequestFilter {

        @Override
        public void filter(ClientRequestContext requestContext) {
            // Лабораторная 3: разобраться как работает данный фильтр
            // и добавить логирование METHOD и HEADERS.
            Logger.debug(createLogMessageFrom(requestContext));
        }

        private String createLogMessageFrom(ClientRequestContext context) {
            String message =
                    "Method name: " + context.getMethod() + "\n" +
                    "Headers: " + context.getStringHeaders().toString() + "\n";

            if (context.hasEntity()) {
                message += "Body: " + context.getEntity().toString();
                message += "Headers: " + context.getStringHeaders().toString() + "\n";
            }

            return message;
        }
    }

}
