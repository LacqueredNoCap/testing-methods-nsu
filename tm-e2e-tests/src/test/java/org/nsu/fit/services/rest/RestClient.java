package org.nsu.fit.services.rest;

import javax.ws.rs.ProcessingException;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.ClientRequestContext;
import javax.ws.rs.client.ClientRequestFilter;
import javax.ws.rs.client.Entity;
import javax.ws.rs.client.Invocation;
import javax.ws.rs.core.MediaType;

import java.util.Random;

import net.moznion.random.string.RandomStringGenerator;
import org.glassfish.jersey.client.ClientConfig;

import org.nsu.fit.services.log.Logger;
import org.nsu.fit.services.rest.data.AccountTokenPojo;
import org.nsu.fit.services.rest.data.ContactPojo;
import org.nsu.fit.services.rest.data.CredentialsPojo;
import org.nsu.fit.services.rest.data.CustomerPojo;
import org.nsu.fit.shared.JsonMapper;

public class RestClient {
    // Note: change url if you want to use the docker compose.
    //private static final String REST_URI = "http://localhost:8080/tm-backend/rest";
    private static final String REST_URI = "http://localhost:8089/tm-backend/rest";

    private static final Client CLIENT =
            ClientBuilder.newClient(new ClientConfig().register(RestClientLogFilter.class));

    private static final RandomStringGenerator STRING_GENERATOR = new RandomStringGenerator();

    private static final Random INT_GENERATOR = new Random();

    public AccountTokenPojo authenticate(String login, String pass) {
        CredentialsPojo credentialsPojo = new CredentialsPojo(login, pass);

        return post(
                "authenticate",
                JsonMapper.toJson(credentialsPojo, true),
                AccountTokenPojo.class,
                null
        );
    }

    public CustomerPojo createAutoGeneratedCustomer(AccountTokenPojo accountToken) {
        // Лабораторная 3: Добавить обработку генерацию фейковых имен, фамилий и логинов.
        // * Исследовать этот вопрос более детально,
        // возможно прикрутить специальную библиотеку для генерации фейковых данных.
        ContactPojo contactPojo = new ContactPojo(
                STRING_GENERATOR.generateByRegex("[A-Z][a-z]{1,11}"),
                STRING_GENERATOR.generateByRegex("[A-Z][a-z]{1,11}"),
                STRING_GENERATOR.generateByRegex(
                        "[a-z][a-z0-9]{1,9}\\.[a-z0-9]{1,10}@[a-z]{2,6}\\.[a-z]{2,3}"
                ),
                STRING_GENERATOR.generateByRegex("\\S{8,12}"),
                INT_GENERATOR.nextInt(1001)
        );

        return post(
                "customers",
                JsonMapper.toJson(contactPojo, true),
                CustomerPojo.class,
                accountToken
        );
    }

    private static <R> R post(String path,
                              String body,
                              Class<R> responseType,
                              AccountTokenPojo accountToken) {
        // Лабораторная 3: Добавить обработку Responses и Errors. Выводите их в лог.
        // Подумайте почему в filter нет Response чтобы можно было удобно его сохранить.
        Invocation.Builder request = CLIENT
                .target(REST_URI)
                .path(path)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        String httpResponse;
        R response = null;
        try {
            httpResponse = request.post(
                    Entity.entity(
                            body,
                            MediaType.APPLICATION_JSON
                    ),
                    String.class
            );
            Logger.debug("Response: " + httpResponse);

            response = JsonMapper.fromJson(httpResponse, responseType);
        } catch (ProcessingException | WebApplicationException e) {
            Logger.error("Ошибка при вызове POST метода в ответ за запрос", e);
        } catch (RuntimeException e) {
            Logger.error("Ошибка при парсинге ответа из Json", e);
        }

        return response;
    }

    private static class RestClientLogFilter implements ClientRequestFilter {
        @Override
        public void filter(ClientRequestContext requestContext) {
            // Лабораторная 3: разобраться как работает данный фильтр
            // и добавить логирование METHOD и HEADERS.
            Logger.debug(createLogMessageFrom(requestContext));
        }

        private String createLogMessageFrom(ClientRequestContext context) {
            // Map<String, List<String>> headers = new HashMap<>(context.getStringHeaders());

            return "Method name: " + context.getMethod() + "\n" +
                    "Headers: " + context.getStringHeaders().toString() + "\n" +
                    "Body: " + context.getEntity().toString();
        }
    }

}
